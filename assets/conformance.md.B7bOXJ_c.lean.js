import{_ as t,c as a,a4 as o,o as n}from"./chunks/framework.CQS5UjL2.js";const u=JSON.parse('{"title":"DICOM Conformance","description":"","frontmatter":{},"headers":[],"relativePath":"conformance.md","filePath":"conformance.md"}'),i={name:"conformance.md"};function r(s,e,d,c,l,f){return n(),a("div",null,e[0]||(e[0]=[o('<h1 id="dicom-conformance" tabindex="-1">DICOM Conformance <a class="header-anchor" href="#dicom-conformance" aria-label="Permalink to &quot;DICOM Conformance&quot;">​</a></h1><p>DCMfx reads all valid DICOM Part 10 (P10) data, as well as many DICOM files that that don&#39;t strictly conform to the DICOM P10 standard.</p><p>When writing DICOM P10 data, strict conformance of the data being written is <em>not</em> enforced, because any DICOM P10 data that was able to be <em>read</em> should also be able to be <em>written</em>, even if parts of it were non-conformant in some way. Still, many variants of invalid DICOM P10 data or files will be corrected by going through a read/write cycle in DCMfx.</p><h2 id="utf-8-conversion" tabindex="-1">UTF-8 Conversion <a class="header-anchor" href="#utf-8-conversion" aria-label="Permalink to &quot;UTF-8 Conversion&quot;">​</a></h2><p>DCMfx converts all strings to UTF-8 when reading DICOM P10 data. This is because native DICOM string data is complex to work with, and UTF-8 is the preferred string encoding of modern systems.</p><p>All Specific Character Sets defined by the DICOM standard are supported, including the use of Code Extensions via ISO 2022 escape sequences. If an invalid byte is encountered during UTF-8 conversion then it is converted to the � (U+FFFD) character.</p><p>Due to the UTF-8 conversion, DICOM P10 data written by this library always uses the <code>ISO_IR 192</code> (UTF-8) Specific Character Set.</p><h2 id="sequences-and-items-of-undefined-length" tabindex="-1">Sequences and Items of Undefined Length <a class="header-anchor" href="#sequences-and-items-of-undefined-length" aria-label="Permalink to &quot;Sequences and Items of Undefined Length&quot;">​</a></h2><p>DCMfx converts sequences and items that have defined lengths to use undefined lengths with explicit delimiters. This consumes slightly more space, which may be noticeable for data sets with a very large number of sequences or items, but is necessary in order to be able to stream DICOM P10 data in a memory-efficient way.</p><h2 id="dicom-json" tabindex="-1">DICOM JSON <a class="header-anchor" href="#dicom-json" aria-label="Permalink to &quot;DICOM JSON&quot;">​</a></h2><p>DCMfx supports conversion to and from the DICOM JSON Model. The following details are relevant to users of this feature:</p><ol><li><p>The DICOM JSON specification is optionally extended to allow encapsulated pixel data to be stored. This is done by encoding the binary data present in the &#39;(7FE0,0010) PixelData&#39; data element in Base64. This matches the behavior of other libraries such as <a href="https://pydicom.github.io/" target="_blank" rel="noreferrer"><code>pydicom</code></a>.</p></li><li><p><code>BulkDataURI</code> specifiers for storing and retrieving data from external sources are not supported. Binary data must be encoded inline using Base64.</p></li><li><p>Because floating point <code>Infinity</code>, <code>-Infinity</code>, and <code>NaN</code> are not supported by JSON&#39;s <code>number</code> type, DCMfx stores them as quoted strings: <code>&quot;Infinity&quot;</code>, <code>&quot;-Infinity&quot;</code>, and <code>&quot;NaN&quot;</code>.</p></li><li><p>64-bit integer values outside the range representable accurately by JavaScript&#39;s <code>number</code> type are stored as quoted strings to avoid any loss of precision.</p></li></ol>',12)]))}const m=t(i,[["render",r]]);export{u as __pageData,m as default};
